![leafSun](https://user-images.githubusercontent.com/32124230/107999911-9f3f1100-6fe0-11eb-9755-f48dbb82cf65.png)

# DOCUMENTATION

# Table of Contents
* [Background](#background)
  * [Climate data](#climate-data)
  * [Crop data](#crop-data)
* [Basic operation](#basic-operation)
* [Model Tab](#model-tab)
  * [Modelling task](#modelling-task)
  * [Required data format and upload](#required-data-format-and-upload)
  * [Sampling strategy](#sampling-strategy)
  * [Reproducible results](#reproducible-results)
  * [Parallel computing](#parallel-computing)
  * [Results table](#results-table)
  * [Final model version](#final-model-version)
  * [Saving model results](#saving-model-results)
* [Projections tab](#projections-tab)
  * [Climate and crop panel](#climate-and-crop-panel)
  * [Results panel](#results-panel)
    * [How to incorporate cell areas](#how-to-incorporate-cell-areas)
    * [Select a distribution of locations](#select-a-distribution-of-locations)
    * [Artificial landscape generation](#artificial-landscape-generation)
  * [Dispersal panel](#dispersal-panel)
    * [Choose the type of dispersal](#choose-the-type-of-dispersal)
    * [Create the dispersal function](#create-the-dispersal-function)
  * [Plots panel](#plots-panel)
    * [Making maps](#making-maps)
    * [Plotting projected values](#plotting-projected-values)
    * [Saving results](#saving-results)
  
# Background
The app provides a very simple front-end to cutting edge machine learning algorithms, and is bundled with gridded crop distribution and climate change data. With a few button clicks you can fit a weather-dependent regression- or classification-tree ensemble to your own data, apply your model across real crop locations, and explore possible future changes under various climate change scenarios. 

### Climate data
The app uses seasonal 12 km gridded (65 x 112 cells) climate data from the UK Met Office Climate Projections database [UKCP18](https://www.metoffice.gov.uk/research/approach/collaboration/ukcp/index) 12-member ensemble of Regional projections. The following variables are provided: temperature (deg. C), relative humidity (%), wind speed (m s<sup>-1</sup>), net surface shortwave radiation flux (W m<sup>-2</sup>), precipitation (mm d<sup>-1</sup>), total cloud (%). The data are at presented at seasonal timescales (spring, summer, autumn, and winter) for each decade spanning 2020s-2060s. UKCP18 data for 1981-2000 are included as baseline values for comparison. All the climate data have full spatial and temporal coherence, enabling the assessment of multiple climatic drivers of changing hazards across multiple geographic locations. The data provide 12 equally plausible snapshots of climate change for emissions scenario RCP8.5, meaning that fitted models will produce an ensemble of 12 projected values for each grid cell, and a super-ensemble of results for each crop species distribution.

### Crop data
Polygon data defining the spatial coverage of crops and land-use types were derived from [IACS](https://ec.europa.eu/agriculture/direct-support/iacs_en) and [JACS](https://www.gov.scot/collections/june-scottish-agricultural-census/). These data cover Scotland only. The vector data were rasterised to 12 km grids matching the resolution of the climate change data. Information on the abundance (area) of crop in each grid cell is used for visualisation purposes only, and the presence-absence of selected crop species is used to narrow the climate change risk assessment to relevant grid cells.  

# Basic operation
*Tabs*: The app has two 'tabs' - 'Model' and 'Projections.' Click on the tab name to switch from one to the other.  
*Switches*: Drag the circluar switch to the left or right, or click in the empty space.  
*Lists*: Click on the desired option in the list.  
*Buttons*: Click them.  
*Numeric fields*: Click in the white box to change the numerical value, then hit enter or click outside the box.  
*State buttons*: Click them to toggle between two states - dark grey indicates 'on' and light grey is 'off'.  
*Knobs*: Drag the circular control around to your selection, or click on your selection.  
Note: some controls may be unavailable (greyed out) until certain operations have been performed, for example, model results cannot be saved until a model has been fitted to your data.  

# Model Tab
The risk models you create here must be a function of one or more of the weather variables included in the climate change projection data. Inclusion of other weather variables will produce meaningless results. Your 'response variable' (dependent variable) can be any weather-dependent process involving / affecting / occurring in or around crops, e.g., crop diseases, pests, crop growth etc.    

### Modelling task
The app uses the MATLAB commands ``fitrensemble`` to fit regression tree ensembles, and ``fitcensemble`` to fit classification tree ensembles, depending on the required modelling task. This is selected using the 'Task' switch. For regression tasks your Y variable should be continuous and for classification tasks it must be categorical. If an attempt is made to upload data that do not match the selected task, a warning will be issued and the data will not be loaded. 

### Required data format and upload
To upload your data click the 'Load' button. This will open up a dialogue box that allows you to search for your file. Data files must be .xls or .xlsx. Data should be arranged in rows with columns for the different weather variables. The column header for the response (dependent) variable should be an upper case Y, and the column headers for your weather variables should be all lower case: temp, rh, rain, wind, rad, cloud. It doesn't matter what order the columns are in, and you can include as many of the set of 6 weather variables as required. Missing data should be left as blank cells and these will be ignored during model fitting; do not use numerical missing data identifiers (e.g., -9999) as these will be treated as numbers. Text entries will be treated as missing data. Data for classification tasks require a little more consideration. Your categorical response variable must be coded as integers and not any form of character or string array (text, alphanumeric, symbols etc.), e.g., low, medium, and high should be converted to 1, 2, 3. Integers will be treated as discrete classes by the algorithms. This is required to eliminate the risk of typos, use of different date formats etc. You ideally want >25 values of Y for each discrete class. An acceptable performance may be achieved with fewer samples per class, but <5 per class on average will result in a warning and the data will not load. Consider aggregating the classes into fewer categories if the data per class is sparse, and fitting an algorithm on the new data to see if performance is improved. Unbalanced data, where the class proportions are skewed, is not a serious concern as the algorithms are ensembles of decision trees that handle imbalanced data quite well, If the performance of a fitted classifier is poor, however, you may want to consider addressing this via, e.g., upsampling or downsampling. Two synthetic datasets are included for regression and classification, and you can refer to these if in doubt about the required data format. 

### Sampling strategy
The primary objective in applied machine learning is to maximize predictive accuracy on new (unseen) data. Resampling methods are statistical procedures for sampling a dataset that are used to estimate this unknown quantity. The algorithms used in the app have parameters that are learned from the data (known as training) and hyperparameters that affect the learning process, whose value must be set before learning begins (finding the optimal values is known as tuning). Resampling methods use different protions of a dataset for training, tuning, and testing of predictive accuracy. This provides an estimate of how well the entire model building process will perform on average when confronted with new data, and how much it is expected to vary in practice. This is useful for reporting purposes and to compare different algorithms and algorithm versions. Once the skill of a machine learning procedure on unseen data has been estimated we are finished with resampling, we discard all of the trained/tuned models, and move directly to creating the [final model version](#final-model-version). Finalization is done automatically in the app after resampling.  

A number of sampling strategies are provided in the 'Sampling' list. If 'none' is selected then all the data will be used for learning, default values for the hyperparameters will be used (no tuning), and the model will be 'tested' using all the data it has already learned from. This is the least desirable option as it can lead to 'overfitting' and does not provide an estimate of the skill of the process on unseen data. It is, however, the fastest option for obtaining a model to be used in the [Projections tab](#projections-tab) of the app. The next 3 options are prefixed by 'NCV' which stands for nested cross-validation. Cross-validation, or *k*-fold cross-validation, is a useful resampling procedure when the size of the dataset is limited. Cross-validation has a single hyperparameter *k* that controls the number of subsets that a dataset is split into. Once split, each subset is given the opportunity to be used as a test set while all other subsets are combined as the training dataset. This means that *k*-fold cross-validation involves fitting and evaluating *k* versions of an algorithm. This, in turn, provides *k* estimates of an algorithm's performance on the dataset. In nested CV there are two loops of CV: an inner and an outer loop. Each training set of the outer cross-validation is further subdivided into folds in an inner loop of CV to find the best hyperparameter values for that training set. This is achieved using 'Bayesian optimization', via MATLAB's ``bayesopt`` command with *k* = 5. Once the optimal hyperparameter values are found, the algorithm is retrained and tested in the outer loop. This is considered to be the 'gold-standard' approach in machine learning, but it is computationally expensive and may be slow to run depending on the size of your dataset. The outer loop can be *k* = 5, *k* = 10, or 'loocv', which stands for leave-one-out cross-validation. This is an extreme version of *k*-fold cross-validation where *k* is set to the number of examples in the dataset. It requires one model to be created and evaluated for each example in your dataset, and therefore has the maximum computational cost and is not appropriate for large datasets. Finally, there is the 'holdout' option, in which 80% of your data is used for training and tuning in a 5-fold Bayesian optimization, and 20% is 'held out' for testing the optimized algorithm.  

One of the above strategies will be automatically selected for you based on the size of your dataset, but this can be overridden. Automatic selection follows a commonly used approach based on the number of examples  *n* in your dataset: *n* <= 20 = 'loocv', 20 < *n* <= 100 = 10-fold, 100 < *n* <= 10,000 = 5-fold, and *n* > 10,000 = 'holdout'. A value of *k* = 10 is very common in the field of applied machine learning and is recommend if you are struggling to choose a strategy for your dataset. Note that for classification tasks the app implements 'stratified sampling' to ensure that the ratio of the observations in each class remains the same in each sample, which is useful for imbalanced datasets. Also note that prior to sampling the rows of data are randomly shuffled to ensure that samples are representative of the overall distribution of the data, which may not be the case if they have been artificially ordered (by class, for example). 

### Reproducible results
The 'Seed' numeric field specifies the seed for the MATLAB random number generator and can be used to ensure that all random shuffles and splits of the data are fully reproducible, providing reproducible results for the Model tab for the same seed value. Reproducibility can be affected, however, if you set the app to utilise parallel computing (see below).

### Parallel computing
Training, tuning, and testing an algorithm can be computationally expensive, therefore making use of parallel computing is advised if you have a multicore device. This is achieved by depressing the 'Parallel' state button (it will change from light grey to dark grey). This may mean, however, that parallel Bayesian optimization (tuning) does not yield exactly reproducible results, due to the nonreproducibility of parallel timing.

### Train / tune / test results table
The table provides results for each iteration of the selected sampling strategy. For 'none' and 'holdout' there will be one row and for sampling strategies prefixed by NCV there will be *k* rows of results in the table. These will appear one-by-one as the app cycles through each iteration of sampling. The columns are explained as follows. 'Fold' provides the number of the test fold (i.e., the iteration count). 'Method' provides the best estimated learner (ensemble aggregation algorithm) on the test fold. The next 5 or 6 columns provide the optimized hyperparameter values for regression and classification, respectively (note that column headings for hyperparameters change according to the modelling task selected). The final two columns provide a measure of predictive accuracy on the training fold and test fold. For regression this is the mean squared error of prediction and for classification it is the misclassification rate (proportion of cases misclassified). If 'none' is selected as the sampling strategy then the test accuracy will be NaN (not a number) as no test data were set aside. Although test accuracy is the primary metric of interest, predictive accuracy on training folds is provided for comparison. Performance is often slightly lower on test folds, but if there is a large discrepancy in training and test accuracy it indicates a poor ability of the algorithm to generalize to new, unseen data. For reporting purposes you can provide the individual results on each test fold (Test column) or the mean and SD across the test folds. If NaN appears for any hyperparameter value, this indicates that the best estimated learner does not use that hyperparameter. A description of the various ensemble aggregation algorithms (and their hyperparamters) that can be returned by ``fitrensemble`` and ``fitcensemble``is beyond the scope of this documentation, but the interested reader can consult the [MATLAB documentation](https://www.mathworks.com/help/index.html?s_tid=CRUX_topnav). 

### Final model version
The details of the finalized algorithm will automatically appear in the 'Final version' table after assessment of the model building process via resmapling is complete. If the sampling strategy selected was 'none', then default settings were used for ``fitrensemble`` / ``fitcensemble`` and the default learner has already been trained on all the available data. Otherwise, one more round of Bayesian optimization with 5-fold cross-validation is performed using to obtain the best learner and optimal hyperparameter settings, and the resultant optimized learner is retrained using all the data.

### Saving model results
Once the 'Save' button becomes available (after resampling and model finalization), this can be used to open up a dialogue box to save modelling results to a location of your choice. The results file is an excel workbook with 4 worksheets: 'testCases' contains the variables used and predicted values for Y in each test fold, 'performance' contains the Train / tune / test results table, 'finalModel' contains the Final version table, and 'importance' contains estimates of predictor importance dervied from ``fitrensemble`` / ``fitcensemble``. These are numerical values between 0 and 1, with higher scores indicating variables that had a greater impact on making predictions.  

# Projections Tab

## Climate and crop panel
Select your climate variable, future time-period, and CO2 emissions scenario using the knobs. Select the month of the year or the season using the list box. For seasonal averages of the selected climate variable, Spr = spring (MAM), Sum = summmer (JJA), Aut = autumn (SON), and Win = winter (DJF). The climate change data are probabilistic, therefore a range of climate values will be provided for each grid cell (see [Climate data](#climate-data)).

## Landscapes panel
Here you define the distribution of locations (grid cells) that you want to use in your risk assessment. 

### How to incorporate cell areas
The 'Areas' radio buttons (No / Yes) are used to determine whether or not you want the area crop / land use type within each 25 km grid cell to be incoporated into risk model projections. 'No' = projections are made for every grid cell containing the crop / land use of interest. 'Yes' = projected values incorporate the area of crop / land use within each grid cell, and if required, also a cell density parameter that is set using the numeric field below the 'Yes' radio button: projected value = risk model value x area x density. The following examples demonstrate how these radio buttons and the density numeric field can be combined for a wide variety of different outcomes:
1. Your risk model describes the impact of a climate variable on any response variable (e.g. disease severity per observational unit,  crop growth rate, etc.). To project future values of the response variable in grid cells containing any amount of the land use type of interest, select 'No': projected value = risk model value.
2. Your risk model describes the impact of climate on the density of a variable per square meter of crop cover (e.g. pests per square meter of crop cover). To project the total number in each grid cell, select 'Yes' and leave the density field equal to 1 (i.e. square meters of crop per square meter of crop): projected number per cell (pests) = risk model value (pests m<sup>-2</sup>) x area of crop per cell (m<sup>2</sup>) x 1 (m<sup>2</sup> m<sup>-2</sup>).
3. Your risk model describes the impact of climate on the density of a variable per square meter of crop canopy (e.g. lesions per square meter of foliage). To project the total number in each grid cell, select 'Yes' and set the density field equal to the ratio of canopy area to ground area (i.e. the leaf area index, LAI): projected number per cell (lesions) = risk model value (lesions m<sup>-2</sup>) x area of crop per cell (m<sup>2</sup>) x LAI (m<sup>2</sup> m<sup>-2</sup>).
4. Your risk model describes the impact of climate on the density of a variable per observational unit (e.g. spores per lesion). To project the total number of spores in each grid cell, select 'Yes' and set the density field equal to the ratio of the observational unit to crop area (e.g. lesions per square meter of crop cover): projected number per cell (spores) = risk model value (spores lesion<sup>-1</sup>) x area of crop per cell (m<sup>2</sup>) x density of lesions (lesions m<sup>-2</sup>).
5. Your risk model describes the impact of climate on the per capita growth rate of a population of organisms. To obtain the future population size within the habitat / host contained in each grid cell, select 'Yes' and set the density field equal to the initial number of organisms per square meter of crop: projected number per cell (individuals) = risk model value (-) x area of crop per cell (m<sup>2</sup> crop) x initial density (individuals m<sup>-2</sup>). Note that the growth rate in your risk model should be a monthly or seasonal per capita growth rate to match the temporal resolution of the climate change data (see [Climate data](#climate-data)). 

The density parameter can be used in many other ways; just make sure you do a dimensional analysis, as above, so that the units on the left hand side of the equality operator match the units on the right hand side.

### Select a distribution of locations
Select a region of the Scotland or England using the 'Region' knob. Sco_N, Sco_E, Sco_W = Northern, Eastern and Western Scotland, respectively. Eng_N, Eng_M, Eng_SE, Eng_SW = North, Midlands, South East, and South West England, respectively. Once a region is selected, choose a spatial distribution of crop / land use locations using the  'Crop / land use' list box: P = potato, SB = spring barley, WB = winter barley, SO = spring oats, WO = winter oats, SW = spring wheat, WW = winter wheat, F = forestry, W = water bodies (ponds, lakes, rivers).

### Artifical landscape generation
The 4C model also allows you to generate your own distribution of locations. This is useful if the crop distribution desired is not available, and for adaptation scenarios involving a change in the amount and spatial distribution of crop locations. Artifical landscapes are generated using fractal geometry (the ‘inverse Fourier transform' method) to create binary landscape patterns of occupied / unoccupied cells (e.g. habitat / non-habitat). Select 'Artificial' using the switch. Set 'Seed' using the numeric field - this controls the random generation of patterns, allowing you to replicate a pattern by using the same value for seed. The 'f' numeric field (0,1) sets the fraction of GB land area that will be occupied. The 'H' numeric field (0,1) controls the degree of aggregation of occupied cells via a parameter known as the Hurst exponent. The 'r' numeric field (0.01,1) controls the texture of the pattern, or the size distribution of gaps among occupied cells, via a parameter known as the lacunarity.

## Dispersal panel
The features in this panel are used to define spatial relationships among grid cells, i.e. physical dispersal among cells, or degree of connectivity among cells (on a scale of 0 to 1). These spatial relationshps are used to modify the projected values from your risk model. For those who are interested, spatial phenomena are solved by performing a spatial convolution between the distribution of risk model values in the selected cells and a 2D radially-symmetric probability density function (dispersal kernel), implemented via fast Fourier transforms (see [Skelsey et al. 2013](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0075892)). 

### Choose the type of dispersal
The 'Dispersal' knob is used to define three different types of spatial relationship among cells: 
1. No dispersal - set 'Dispersal' to 'Off.' This means that projected values from your risk model are not modified to incorporate a spatial relationship among cells.
2. Dispersal is a physical process involving absolute numbers of dispersing agents - set 'Dispersal' to 'Std.' or 'No self.' In both cases, the projected values from your risk model are treated as a 'source' of material (an amount per cell) to be dispersed among other grid cells. When 'Std.' (standard) is selected, source values are dispersed among all grid cells *including* the cell of origin. An example would be passive dispersal of spores, whereby a proportion deposit close to the infection source (in the same grid cell). When 'No self.' (no selfing) is selected then all source material is dispersed outwith the boundaries of the source cell. An example would be active dispersal of pests away from a depleted habitat resource. When 'No self.' is selected the centre of the dispersal kernel is set to 0.   
3. Dispersal is a weighting factor, ranging from 0 to 1, that describes the degree of connectivity of each cell to all other cells - set 'Dispersal' to 'Conn.' In this case the dispersal kernel is normalized to a maximum value of unity. An example would be a risk model that projects the likelihood of pest occurrence (on a scale of 0 to 1), which is then weighted according to the connectivity of host cells (on a scale of 0 to 1) to provide projections of the risk of pest occurrence and spread (on a scale of 0 to 1). 

### Create the dispersal function
To change the dispersal function use the 'Kernel' knob:  fat = fat-tailed (square-root negative exponential kernel), thin = thin-tailed (negative exponential kernel), Gauss = Gaussian kernel. These three kernels are all derived from the exponential-power distribution and all have a different shape (see [Skelsey et al. 2013](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0075892) for a thorough explanation). Fat-tailed kernels are often used for processes that operate at broad spatial scales, such as long-distance dispersal by wind, whereas thin-tailed kernels are often used for processes that operate at fine spatial scales, such as splash dispersal. The kernel is parameterized using the 'mdd' numeric field = mean dispersal distance. Enter a number for the average distance that an individual can disperse. A 1D slice through your dispersal kernel (i.e. a dispersal gradient) is automatically displayed in the 'Dispersal gradient' plot pane.

## Plots panel

### Making maps
Click the 'Map' button to the left of the 'Map of climate variable / land use' plot pane. Switch between a map of the selected climate variable and a map of the selected crop / land use distribution using the 'Plot' radio buttons immediately beneath. 

### Plotting projected values
Once your future scenario has been defined, click the 'Project' button to the left of the 'Boxplots of projected values' plot pane. This will produce a boxplot of projected values for that scenario. Each boxplot is a 'super-ensemble' of projected values (11 SCPs x *n* selected grid cells). Boxes extend from the first to the third quartile, medians are marked in each box, and whiskers extend to 1.5 times the interquartile range. You can display multiple boxplots (i.e. multiple scenarios, such as a different month of the year / decade / emissions level / risk model / crop distribution, etc.) together in the plot pane. Click the 'Clear' button to clear the plot pane. The 'Plot' radio button 'Abs' will plot the absolute projected values from your risk model. The 'Chg' radio button will plot the projected values relative to those for the 1961-1991 baseline climatology to show the proportional response; i.e. the percentage change in the response variable relative to baseline conditions. The 'Scale' radio buttons 'Lin.' and 'Log.' will change the scale of the y-axis from linear to logarithmic.   

### Saving results
Click the 'Save' button to save your results. This will open up a file save dialog box, where you can name your results file and save to any location. Note that only the results for the boxplots displayed in the plot pane will be saved - if you click the 'Clear' button then these results will be lost. Your results will be saved to an ASCII file, and the projected values for each scenario you define (each boxplot) will be stored in a separate column. Each column will contain 22308 values (52 x 39 cells x 11 SCPs). Only a small proporition of these values will be numerical, pertaining to the grid cells you selected for your projections. The rest will be NaN (not a number), representing the grid cells (land and sea) not selected. 



